# -*- coding: utf-8 -*-
"""final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dn3qE4hYIXjMuLInVglekumO1ATVk7Ct
"""

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

def generate_and_store_keys(public_key_filename, private_key_filename):
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048
    )

    with open(private_key_filename, "wb") as private_key_file:
        private_key_file.write(
            private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption()
            )
        )

    public_key = private_key.public_key()
    with open(public_key_filename, "wb") as public_key_file:
        public_key_file.write(
            public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
        )

if __name__ == "__main__":
    public_key_filename = "public_key.pem"
    private_key_filename = "private_key.pem"

    generate_and_store_keys(public_key_filename, private_key_filename)
    print("Keys generated and stored successfully.")

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding as pd
from cryptography.hazmat.primitives import asymmetric

def encrypt_message(public_key_filename, plaintext):
    with open(public_key_filename, "rb") as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend=None
        )


    ciphertext = public_key.encrypt(
        plaintext,
        pd.OAEP(
            mgf=pd.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return ciphertext

def decrypt_message(private_key_filename, ciphertext):

    with open(private_key_filename, "rb") as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password=None,
            backend=None
        )


    plaintext = private_key.decrypt(
        ciphertext,
        pd.OAEP(
            mgf=pd.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return plaintext

from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import padding as sym_padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
import base64
import os

def generate_aes_key(passphrase, salt):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        iterations=100000,
        salt=salt,
        length=32,  # 256 bits
        backend=default_backend()
    )
    key = kdf.derive(passphrase)
    return key

def encrypt_message2(aes_key, plaintext):
    iv = os.urandom(16)  # Generate a random IV (Initialization Vector)
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    return iv + ciphertext

def decrypt_message2(aes_key, ciphertext):
    iv = ciphertext[:16]
    ciphertext = ciphertext[16:]
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return decrypted_plaintext

def main_encrypt(plaintext):
    public_key_filename = "public_key.pem"
    private_key_filename = "private_key.pem"






    passphrase = b"viywiegfIGGEWGYGBDHBHJVfew"
    salt = os.urandom(16)
    key = generate_aes_key(passphrase, salt)
    as_en_ciphertext = encrypt_message(public_key_filename, key)
    print("Ciphertext:", as_en_ciphertext)
    decrypted_text = decrypt_message(private_key_filename, as_en_ciphertext)
    print("Decrypted:", decrypted_text)

    ciphertext = encrypt_message2(decrypted_text, plaintext)
    print("Ciphertext:", base64.b64encode(ciphertext).decode())

    decrypted_text = decrypt_message2(decrypted_text, ciphertext)
    decrypted_text=decrypted_text
    print("Decrypted:", decrypted_text)
    return decrypted_text

plaintext="ejfbewbewuiew"
main_encrypt(plaintext)

def read_data_from_a_file(file_path):
  try:
      with open(file_path, 'rb') as file:
          binary_data = file.read()
      return binary_data

  except FileNotFoundError:
      print("File not found.")
  except Exception as e:
      print("An error occurred:", e)

filepath='/content/Mask group.png'
a=read_data_from_a_file(filepath)
print(a)

d=main_encrypt(a)

def write_file(file_path,d):

  try:
      with open(file_path, 'wb') as file:
        file.write(d)



  except FileNotFoundError:
      print("File not found.")
  except Exception as e:
      print("An error occurred:", e)



import os

def file_help(file_path):
  directory_path = os.path.dirname(file_path)
  file_name_with_extension = os.path.basename(file_path)
  file_name, file_extension = os.path.splitext(file_name_with_extension)

  print("Directory Path:", directory_path)
  print("File Name:", file_name)
  print("File Extension:", file_extension)
  return directory_path,file_extension,file_name

file_path = '/content/Mask group.png'

def make_upload_folder(file):
  try:
      a=read_data_from_a_file(file)
      key=b"wbbweubw"
      d=main_encrypt(a)
      d1,get_extension,folder_name=file_help(file)
      os.mkdir(folder_name)
      print(f"Folder '{folder_name}' created.")
  except FileExistsError:
      pass
  file_name='encrypted'+str(get_extension)
  file_path = os.path.join(d1,folder_name, file_name)
  write_file(file_path,d)
  file_name='key.txt'
  file_path = os.path.join(d1,folder_name, file_name)
  print(key)
  write_file(file_path,key)

make_upload_folder('/content/Mask group.png')

import os
import requests
api_token="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweDA4YjM2QThBMDk4NDA3Y0U0QTI0OTVlMEE5NzYzYjE1MDk5ODlFNTYiLCJpc3MiOiJ3ZWIzLXN0b3JhZ2UiLCJpYXQiOjE2OTE3NzE5MjcxMDksIm5hbWUiOiJmaWxlX3NoYXJlIn0.ljp6uNn1r3YmRtMC0sHjWjrVhMDYRaEQUH8oUEJzStQ"
upload_url = "https://api.web3.storage/upload"

folder_path = "/content/Mask group"

headers = {
    "Authorization": f"Bearer {api_token}"
}

files = []
final_cid=""
for root, _, filenames in os.walk(folder_path):
    for filename in filenames:
        file_path = os.path.join(root, filename)
        with open(file_path, "rb") as file:
                files = {"file": file}
                response = requests.post(upload_url, headers=headers, files=files)

                if response.status_code == 200:
                    print("File uploaded successfully!")
                    print("CID:", response.json()["cid"])
                    key = filename
                    final_cid = final_cid+ str(response.json()["cid"])+"_"

                else:
                    print("File upload failed.")
                    print("Response:", response.text)

print(final_cid)

ric=final_cid.split('_')
print(ric)

import requests
for i in range(0,2):
  cid = ric[i]

  ipfs_gateway_url = f'https://ipfs.io/ipfs/{cid}'


  response = requests.get(ipfs_gateway_url)

  if response.status_code == 200:

      with open('downloaded_file'+str(i)+".png", 'wb') as file:
          file.write(response.content)
      print("File downloaded successfully!")
  else:
      print("File download failed.")
      print("Response:", response.text)